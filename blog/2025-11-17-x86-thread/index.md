---
slug: x86-thread
title: 多线程模式
authors: [wjc133]
tags: [x86]
---

前面了解的都是多任务管理，但现代操作系统都以线程为基本执行单位，所以本篇学习如何在多处理器系统下进行多线程管理。

<!-- truncate -->

## 线程带来的结构改变
### 任务链
![画板](img/01.jpeg)

再多线程模型中，任务只是一个容器，线程是一定属于某一任务的。执行时，实际执行的是线程。而进程作为容器则只提供公共的地址空间。所有线程共享进程的资源。

### 进程控制块 PCB
PCB 的结构需要调整，原本我们在 PCB 中存储各个寄存器的内容。由于现在处理器在做任务切换时，实际切换的是线程，所以这些内容要挪到 TCB 中，而 PCB 得到大幅简化。

![](img/02.svg)

+ **任务状态**：现在任务状态可以简化成两种，**运行态**和**终止态**。
+ **CR3**：之所以保留 CR3，是因为 CR3 用于分页，而所有线程是共享进程地址空间的。
+ **线程链表首节点的线性地址**：它指向任务的第一个 TCB。

### 线程控制块 TCB
![](img/03.svg)

## 任务创建和调度流程
![](img/04.svg)

由于执行代码的基本单位从进程变成了线程，所以进程变成了容器。

1. 任务（PCB）管理地址空间、资源等环境；线程（TCB）管理执行流、寄存器、栈、状态和时间片。
2. 主线程的创建：在创建任务（create_process）时，必须同步创建其第一个线程——主线程。主线程的入口点就是任务的入口点。
3. 执行上下文的转移：关键的执行信息（如入口地址、栈、状态、时间片）从 PCB 转移到了 TCB 中。
4. 双重记录：处理器的专属存储区需要同时记录当前任务（PCB）和当前线程（TCB），因为线程在执行时离不开其所属任务的环境。

![](img/05.svg)

5. 调度单位的改变：调度器（search_for_a_ready_thread）寻找的不再是就绪的“任务”，而是就绪的“线程”。
6. 中断处理：新线程认领中断和时间片到期中断的处理逻辑，其操作对象都由任务变为了线程。

## 新建线程
假设当前线程工作在用户态，想要新建线程，需要进行系统调用。线程创建后，系统即将其交给调度器调度。所以什么时间执行新创建的线程在用户程序层面是不可控的。

![](img/06.svg)

**ret 指令的双重语义**：

+ 被 call 调用时：栈中有真实的返回地址，ret 正常返回调用者
+ 作为线程执行时：栈中植入的是线程结束代码地址，ret 会跳转到终止流程

兼容性目标：同一个函数既可以作为传统子程序被调用，也可以作为现代线程并发执行，为系统从单线程向多线程平滑过渡提供了技术基础。

## 线程结束和任务终止
![](img/07.svg)

## 线程休眠
线程休眠后，线程进入阻塞状态，处于阻塞状态的线程不会被 CPU 调度。

我们可以通过设置外部定时器中断，中断发生时处理器检查线程的休眠时间是否到期。

用户程序想要实现线程休眠需要执行系统调用。

系统调用的流程如下：

![](img/08.svg)

系统管理中断处理流程：

![](img/09.svg)

再来看看休眠唤醒的`handle_waiting_sleep`过程：

![](img/10.svg)

## 线程等待
我们所说的线程等待，是指线程 A 需要等待线程 B 执行完才能继续执行的这种情况。

![](img/11.svg)

## 多线程竞争互斥锁
其实互斥锁的本质就是一块共享内存空间，通过原子操作尝试去改变该共享空间的值，只有交换回 0 值（即锁未被占用）的线程才能成功获得锁，而其他线程需要陷入休眠，等待下一次系统管理中断时重新尝试竞争锁。

下面是一个多线程竞争互斥锁的示例流程。

```mermaid
flowchart TD
    Start([用户程序开始执行]) --> Stage1
    
    subgraph Stage1[阶段1: 互斥锁创建和初始化]
        A1[主线程调用main函数] --> A2[执行12号系统调用<br>init_mutex]
        A2 --> A3[内核分配8字节内存]
        A3 --> A4[互斥锁初始化为0]
        A4 --> A5[返回锁地址给用户程序]
        A5 --> A6[保存锁地址到mutex_ptr]
        A6 --> A7[创建线程1和线程2]
    end

    A7 --> Stage2
    
    subgraph Stage2[阶段2: 线程执行与锁操作]
        B1[进入并行执行] --> B2
        
        subgraph B2[线程1执行]
            C1[进入线程1执行循环] --> C2{循环继续?}
            C2 -->|是| C3[保存RCX到栈]
            C3 --> C4[执行13号系统调用<br>acquire_mutex]
            C4 --> C5{lock cmpxchg<br>加锁成功?}
            C5 -->|是| C6[立即返回用户态]
            C6 --> C7[执行inc share_d<br>临界区操作]
            C7 --> C8[执行14号系统调用<br>release_mutex]
            C8 --> C9[互斥锁清零释放]
            C9 --> C10[恢复RCX从栈]
            C10 --> C11[循环次数减1] --> C2
            
            C5 -->|否| C12[保存线程状态到TCB]
            C12 --> C13[设置状态为5<br>等待互斥锁]
            C13 --> C14[记录锁地址到TCB+56]
            C14 --> C15{找到就绪线程?}
            C15 -->|是| C16[切换到新线程执行] --> C2
            C15 -->|否| C17[进入停机循环] --> C2
        end
        
        B1 --> B3
        
        subgraph B3[线程2执行]
            D1[进入线程2执行循环] --> D2{循环继续?}
            D2 -->|是| D3[保存RCX到栈]
            D3 --> D4[执行13号系统调用<br>acquire_mutex]
            D4 --> D5{lock cmpxchg<br>加锁成功?}
            D5 -->|是| D6[立即返回用户态]
            D6 --> D7[执行dec share_d<br>临界区操作]
            D7 --> D8[执行14号系统调用<br>release_mutex]
            D8 --> D9[互斥锁清零释放]
            D9 --> D10[恢复RCX从栈]
            D10 --> D11[循环次数减1] --> D2
            
            D5 -->|否| D12[保存线程状态到TCB]
            D12 --> D13[设置状态为5<br>等待互斥锁]
            D13 --> D14[记录锁地址到TCB+56]
            D14 --> D15{找到就绪线程?}
            D15 -->|是| D16[切换到新线程执行] --> D2
            D15 -->|否| D17[进入停机循环] --> D2
        end
        
        C2 -->|否| C18[线程1结束]
        D2 -->|否| D18[线程2结束]
    end

    C18 --> Stage3
    D18 --> Stage3
    
    subgraph Stage3[阶段3: 周期性唤醒检查]
        E1[每55ms系统管理中断触发] --> E2{还有线程需要检查?}
        E2 -->|是| E3{线程状态为5?}
        E3 -->|是| E4[handle_waiting_flag处理]
        E4 --> E5{lock cmpxchg<br>加锁成功?}
        E5 -->|是| E6[设置线程状态为就绪]
        E6 --> E7[广播线程认领中断] --> E2
        E5 -->|否| E8[线程继续保持等待状态] --> E2
        E3 -->|否| E9[处理其他线程状态] --> E2
        E2 -->|否| E10[中断处理完成]
    end

    E10 --> Stage4
    
    subgraph Stage4[阶段4: 程序结束]
        F1[主线程等待两个线程结束] --> F2[打印共享变量最终值]
        F2 --> F3[程序执行完成]
    end

    F3 --> End([结束])

    %% 样式定义
    classDef default fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
    classDef stage fill:#f3f2fe,stroke:#4a148c,stroke-width:3px;
    classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:2px;
    classDef ends fill:#e8f5e8,stroke:#1b5e20,stroke-width:3px;
    
    class Stage1,Stage2,Stage3,Stage4 stage
    class C2,C5,C15,D2,D5,D15,E2,E3,E5 decision
    class Start,End ends
```

